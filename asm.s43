#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        
        ORG     01900h                  ; start of ram

//PRE-DEFINED VALUES START HERE
;Heart Beat Reference
heartbeat dw    0
result    dw    0
;S1 Transitions
;s1T     db  0x0B, 0x06, 0x03, 0x04, 0x05, 0x00, 0x07, 0x07, 0x0B, 0x0A, 0x0B
s1T     db  0x0B, 0x06, 0x03, 0x04, 0x05, 0x00, 0x07, 0x07, 0x0B, 0x0A
;S2 Transitions
;s2T     db  0x01, 0x02, 0x01, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x00, 0x0B
s2T     db  0x01, 0x02, 0x01, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x00
; Digits    0     1     2     3     4     5     6     7     8     9
digitH  db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xF7
digitL  db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
; Battery bars
battery db      0x20, 0x40, 0x80
//PRE-DEFINED VALUES END HERE

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
        ORG     0FFDEh                  ; vector for TIMER_A1
        DC16    TIMER_A1_ISR            ; set vector for 'TIMER_A1_ISR' routine                                                
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack
main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        bic.b   #0xFF, &P1SEL0          ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF, &P1SEL1          ; Digital I/O is the default
        bic.b   #0xFF, &P9SEL0
        bic.b   #0xFF, &P9SEL1

        bis.b   #0FDh, &P1DIR           ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output
        bis.b   #0FFh, &P2DIR           ; All Port 2 pins as output
        bis.b   #0xFF, &P9DIR           ; All Port 9 pins as output

        bis.b   #06h, &P1REN            ; P1.1, P1.2 Resistor enabled as pullup
        bis.b   #06h, &P1OUT            ; resistor. Push is read as 0 and else 1
                                        
        bis.b   #06h, &P1IE             ; Enable interrupt at P1.1, P1.2
        bic.b   #06h, &P1IES            ; Set interrupt on low-to-high 
                                        ; transition of P1.1, P1.2

        ; Enable LCD segments
        mov     #0xffff, &LCDCPCTL0
        mov     #0xfc3f, &LCDCPCTL1
        mov     #0x0fff, &LCDCPCTL2
        
        mov     #0x041e, &LCDCCTL0      ; Initialize LCD_C
        mov     #0x0208, &LCDCVCTL      ; Initialize voltage
        mov     #0x8000, &LCDCCPCTL     ; Clock synchronization enabled
        mov     #2, &LCDCMEMCTL         ; Clear LCD memory
        bis     #1, &LCDCCTL0           ; Turn LCD on
        bic     #LOCKLPM5, &PM5CTL0     ; Disable the GPIO power-on by default
        call    #displayOption
        
        ; Timer setup
        bis     #CCIE, &TA0CCTL0        ; Enable interrupt for TA0
        bis     #CCIE, &TA1CCTL0        ; Enable interrupt for TA1
        mov     #62500, &TA0CCR0        ; Set the timer capture compare register 0
        mov     #25000, &TA1CCR0        ; Set the timer capture compare register 0
        
        ; Registers
        mov     #0, R5                  ; Represents the state of the program
        mov     #0, R6
        mov     #0x1980, R8             ; Memory direction for accessing records
        mov     #0, R12                 ; Second that passed when reading BPM
        mov     #0, R13                 ; Represents the state of the batery
        mov     #0, R14                 ; Represents odd or even
        mov     #0, R15                 ; Position of the batery list

        bic.b   #06h, &P1IFG            ; To erase a flag raised before

        nop                             ; NOP before setting GIE required by
                                        ; the architecture
        bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        nop                             ; Required after enabling interrupts
        ret

// Objetivo: Activates timer A1
// Precondiciones: activates every time user preses S1
// Postcondiciones: Timer starts
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
startTimer1:
        mov     #TASSEL_2+MC_0+ID_3, &TA1CTL
        nop
        mov     #TASSEL_2+MC_1+ID_3, &TA1CTL
        nop
        ret

// Objetivo: IRS for turning off the heart after 0.2 seconds
// Precondiciones: Should have waited for 0.2 seconds
// Postcondiciones: Heart will turn off from the LCD
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
TIMER_A1_ISR:   ; Second timer that displays the heart afeter 0.2 seconds
        bic.b   #00000100B, &0x0A22
        mov     #TASSEL_2+MC_0+ID_3, &TA1CTL
        nop
        bic.b   #06h, &P1IFG
        reti

// Objetivo: IRS for timer A0 for looping the battery cells 
// Precondiciones: Timer must reached 1 sec
// Postcondiciones: Battery cells will start incrementing by 1 each second
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
TIMER_A0_ISR: ; This timer works for looping the battery cells
        cmp     #6, R13
        jeq     batteryFull
        cmp     #0, R14
        jeq     oddBattery
        jmp     evenBattery 

// Objetivo: Turn on 1 odd battery 
// Precondiciones: R14 must equal 0
// Postcondiciones: 1 odd battery will turn on
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
oddBattery:
        bis.b   battery(R15), &0x0A31
        inc     R13
        inc     R14
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Turn on 1 even battery 
// Precondiciones: R14 must not equal 0
// Postcondiciones: 1 even battery will turn on
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
evenBattery:
        bis.b   battery(R15), &0x0A2D
        inc     R13
        dec     R14
        inc     R15
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Activate timer A0
// Precondiciones: heatbeat has the value 1 which means this subroutine 
// was executed from another subroutine called s7StartBatteryClock
// Postcondiciones: Timer A0 is active
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
startTimerA0:
        mov     #TASSEL_2+MC_3+ID_3, &TA0CTL
        nop
        ret

// Objetivo: Stops timer A0 
// Precondiciones: Timer must reach to 30 seconds
// Postcondiciones: Timer is stopped and R12 will contain value 0. 
// R12 represents the seconds)
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
stopTimerA0:
        mov     #TASSEL_2+MC_0+ID_3, &TA0CTL
        nop
        mov     #0, R12
        jmp     finishedBPM

// Objetivo: Turns on the heart for 0.2 seconds
// Precondiciones: Program must be in state 7
// Postcondiciones: LCD will display a heart timer A1 is activated
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
turnOnHeart:                            ; Subroutine for starting/stoping timer
        bis.b   #00000100B, &0x0A22     ; Turns on the heart
        call    #startTimer1
        ret

// Objetivo: Turn on the clock icon
// Precondiciones: Timer A0 has reached the 30 seconds
// Postcondiciones: R5 will have a value 8
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
finishedBPM:
        mov.b   #00001000B, &0x0A22
        bic.b   #00000100B, &0x0A22
        mov     #8, R5
        bic.b   #06h, &P1IFG
        reti

// Objetivo: ISR for reading what button is pressed and jumping to the proper 
// transition subroutine 
// Precondiciones: S1 or S2 must be pressed 
// Postcondiciones: Jumps to the transitions subroutine based on the 
// button that is pressed
// Autor: Daniel A. Crespo
// Fecha: 23/04/2021
PORT1_ISR:                              ; ISR to activate timer 0 or timer 1
        call    #delay
        mov.b   &P1IFG,R7               ; Record the button that was pressed
        bit.b   #2, R7                  ; If button is s1
        jnz     transitionS1            ; Start timer 0
        bit.b   #4, R7                  ; If button is s2
        jnz     transitionS2            ; Turns on heart

// Objetivo: Looks in the list of trasition to find what will be the next 
// state of the program. 
// Precondiciones: S1 must be pressed
// Postcondiciones: R6 will contain a value of 0 through 11 representing 
// the next state
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
transitionS1:
        mov.b   s1T(R5), R6
        jmp     nextState
 
// Objetivo: Looks in the list of trasition to find what will be the next 
// state of the program. 
// Precondiciones: S2 must be pressed
// Postcondiciones: R6 will contain a value of 0 through 11 representing 
// the next state
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
transitionS2:
        mov.b   s2T(R5), R6
        jmp     nextState


// Objetivo: Decides what state to jump to next  
// Precondiciones: R6 must contain the value 0 through 11 representing the 
// next state of the aplication.
// Postcondiciones: Jumps to the next state
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
nextState:
        cmp     #0, R6
        jeq     optionState
        cmp     #1, R6
        jeq     readState
        cmp     #2, R6
        jeq     logState
        cmp     #3, R6
        jeq     viewLog1State
        cmp     #4, R6
        jeq     viewLog2State
        cmp     #5, R6
        jeq     viewLog3State
        cmp     #6, R6
        jeq     readingBPMState
        cmp     #7, R6
        jeq     countBeatState
        cmp     #9, R6
        jeq     displaySaveState
        cmp     #10, R6
        jeq     saveBPMState
        bic.b   #06h, &P1IFG
        reti
        
        
// Objetivo: Program is in a option state which means that it will display the 
// word OPTION on the LCD
// Precondiciones: Program must be in state 0
// Postcondiciones: R5 will contain 0
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
optionState:
        mov     #0, R5
        call    #displayOption
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Program is in a read state which means that it will display the 
// word READ on the LCD
// Precondiciones: Program must be in state 1
// Postcondiciones: R5 will contain 1
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
readState:
        mov     #1, R5
        call    #displayRead
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Program is in a log state which means that it will display the 
// word LOG on the LCD
// Precondiciones: Program must be in state 2
// Postcondiciones: R5 will contain 2
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
logState:
        mov     #2, R5
        call    #displayLog
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Program is in a viewing log 1 state which means that it will 
// display the first log located in memory
// Precondiciones: Program must be in state 3 
// Postcondiciones: R5 will contain 3, the LCD will display the first log of 
// the BPM
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
viewLog1State:
        mov     #3, R5
        call    #records
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Program is in a viewing log 2 state which means that it will 
// display the second log located in memory
// Precondiciones: Program must be in state 4 
// Postcondiciones: R5 will contain 4, the LCD will display the second log of 
// the BPM
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
viewLog2State:
        mov     #4, R5
        call    #records
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Program is in a viewing log 3 state which means that it will 
// display the third log located in memory
// Precondiciones: Program must be in state 5 
// Postcondiciones: R5 will contain 5, the LCD will display the third log of 
// the BPM and the FRAM memory pointer will shift to the begining
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
viewLog3State:
        mov     #5, R5
        call    #records
        call    #resetMemoryPointer
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Program is in a reading BPM state which means that it will wait for
// the user to start pressing s1 to count the beats
// Precondiciones: Program must be in state 6
// Postcondiciones: R5 will contain 6, FRAM memory address called heartbeat 
// will contain 0 and LCD will display the edges of the battery
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
readingBPMState:
        mov     #6, R5
        mov     #2, &LCDCMEMCTL          
        call    #edgeOfBattery
        mov     #0, heartbeat
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Program is in a counting Beat state which means that it will
// increment a counter called heartbeat each time s1 is pressed.
// Precondiciones: Program must be in state 7 and FRAM memory address called 
// heartbeat must be 0
// Postcondiciones: FRAM memory address called heartbeat will increment by 1 
// and R5 will contain 7
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
countBeatState:
        mov     #7, R5
        call    #turnOnHeart
        inc     heartbeat
        cmp     #1, heartbeat
        jeq     s7StartBatteryClock
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Activates the battery clock
// Precondiciones: heartbeat must be 1
// Postcondiciones: timerA0 will be activated and the battery cells will be cleared.
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
s7StartBatteryClock:
        call    #startTimerA0
        call    #resetBattery
        bic.b   #06h, &P1IFG
        reti 

// Objetivo: Program is in a save state which means that it will ask the user 
// to save the result or not
// Precondiciones: Program must be in state 9
// Postcondiciones: Display the word save on the LCD and R5 will contain 9
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
displaySaveState:
        mov     #9, R5
        call    #displaySave
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Program is in a saving state which means that it will save the 
// resulting BPM to FRAM memory
// Precondiciones: FRAM memory address called result must contain the 
// result of the BPM
// Postcondiciones: FRAM memory address 0x1980 through 0x1986 will be reorginized
// and the result will be added to memory address 0x1980
// Autor: Joshua Cruz, Daniel A. Crespo
// Fecha: 25/04/2021
saveBPMState:
        call    #reorganizeData
        mov     result, &0x1980
        mov     #0,R6
        jmp     nextState

// Objetivo: Shift all the date 1 to the right so that the first data in the 
// list can be re-written.
// Precondiciones: Must be called when the program is in state 5
// Postcondiciones: FRAM localization 0x1984 will contain the value in 0x1982
// and 0x1982 will contain the value in 0x1980
// Autor: Daniel A. Crespo
// Fecha: 25/04/2021
reorganizeData:
        mov     &0x1982, &0x1984
        mov     &0x1980, &0x1982
        ret

// Objetivo: When battery full it will calculate the BPM, display it on the LCD
// and reset the battery back to the initial state. It will also change to the 
// next state after 30 seconds have passed.
// Precondiciones: Must be called when battery reaches full
// Postcondiciones: R13, R14, R15 will contain the value 0, R12 will contain 
// the seconds that have passed and the display will show the reading that 
// was calculated every 6 seconds.
// Autor: Daniel A. Crespo
// Fecha: 25/04/2021
batteryFull:
        add     #6, R12
        call    #calcBPM
        call    #displayResults
        call    #resetBattery
        cmp     #30, R12
        jeq     stopTimerA0
        bic.b   #06h, &P1IFG
        reti

// Objetivo: Resets the states of the batery back to the begining
// Precondiciones: Must be called when battery reaches full or when starting 
// the battery timer for the first time
// Postcondiciones: R13, R14, R15 will contain the value 0 and the battery 
// will be empty
// Autor: Daniel A. Crespo
// Fecha: 25/04/2021
resetBattery:
        call    #clearBatteryCells
        mov     #0, R13                 ; Represents the state of the battery
        mov     #0, R14                 ; Represents odd or even
        mov     #0, R15                 ; Represents the position of the list
        ret

// Objetivo: Slows down the execution of the code to help against button bouncing
// Precondiciones: Must be called every time the button is pressed
// Postcondiciones: R4 will have its value returned from what it had before 
// calling this subroutine 
// Autor: Daniel A. Crespo
// Fecha: 25/04/2021
delay:
        push.b  R4
        mov     #0x2710, R4
    decrement:
        dec     R4
        jnz     decrement
        pop     R4
        ret

// Objetivo: Display the readings found in FRAM. Will cycle through 3 values 
// starting from 0x1980 to 0x1986
// Precondiciones: FRAM localization 0x1980 through 1986 must contain saved readings
// Postcondiciones: LCD will display the saved readings based on the state 3, 4, 5
// Autor: Daniel A. Crespo
// Fecha: 25/04/2021
records:
        mov     @R8+, R14
        call    #displayResults
        ret

// Objetivo: Adjust the memory pointer to the begining
// Precondiciones: Program must be in stage 5
// Postcondiciones: R8 will now contain the beginning address of FRAM (0x1980)
// Autor: Daniel A. Crespo
// Fecha: 25/04/2021
resetMemoryPointer:
        mov     #0x1980,R8
        ret

// Objetivo: Llamar al calculo correspondiente basado en los segundos
// Precondiciones: La localización de memoria encontrado en heartbeat debe 
// contener la cantidad de palpitos.
// Postcondiciones: R14 guardará el resultado BPM
// Autor: Abdiel Cortés Cortés
// Fecha: 24/abril/2021
calcBPM:
        mov     &heartbeat, R14
        cmp     #6, R12
        jeq     calcBPM6
        cmp     #12, R12
        jeq     calcBPM12
        cmp     #18, R12
        jeq     calcBPM18
        cmp     #24, R12
        jeq     calcBPM24
        cmp     #30, R12
        jeq     calcBPM30

// Objetivo: Calcula el BPM despues que transcurrieron 6 segundos
// Precondiciones: La cantidad de heart beats se encuentra almacenada en R14
// Postcondiciones: El valor de BPM se encuentra almacenado en R14
// Autor: Abdiel Cortés Cortés
// Fecha: 24/abril/2021
calcBPM6:
        push.w  R15                     ; Save value of R15 in stack
        mov     #10, R15                ; 6 seconds is 1/10 of a minute
        call    #mulNumbers             ; Multiply heart beats by 10 to calculate BPM
        pop.w   R15                     ; Recover value of R15 from stack
        ret

// Objetivo: Calcula el BPM despues que transcurrieron 12 segundos
// Precondiciones: La cantidad de heart beats se encuentra almacenada en R14
// Postcondiciones: El valor de BPM se encuentra almacenado en R14
// Autor: Abdiel Cortés Cortés
// Fecha: 24/abril/2021
calcBPM12:
        push.w  R15                     ; Save value of R15 in stack
        mov     #5, R15                 ; 12 seconds is 1/5 of a minute
        call    #mulNumbers             ; Multiply heart beats by 5 to calculate BPM
        pop.w   R15                     ; Recover value of R15 from stack
        ret

// Objetivo: Calcula el BPM despues que transcurrieron 18 segundos
// Precondiciones: La cantidad de heart beats se encuentra almacenada en R14
// Postcondiciones: El valor de BPM se encuentra almacenado en R14
// Autor: Abdiel Cortés Cortés
// Fecha: 24/abril/2021
calcBPM18:
        push.w  R15                     ; Save value of R15 in stack
        mov     #10, R15                ; 18 seconds is 3/10 of a minute
        call    #mulNumbers             ; Since we don't have floats,
        mov     #3, R15                 ; to calculate BPM, we first multiply by 10,
        call    #divNumbers             ; and then divide by 3
        pop.w   R15                     ; Recover value of R15 from stack
        ret

// Objetivo: Calcula el BPM despues que transcurrieron 24 segundos
// Precondiciones: La cantidad de heart beats se encuentra almacenada en R14
// Postcondiciones: El valor de BPM se encuentra almacenado en R14
// Autor: Abdiel Cortés Cortés
// Fecha: 24/abril/2021
calcBPM24:
        push.w  R15                     ; Save value of R15 in stack
        mov     #25, R15                ; 24 seconds is 2/5 = 1/2.5 of a second
        call    #mulNumbers             ; Since we don't have floats, to calculate BPM,
        mov     #10, R15                ; we first multiply by 25 (2.5 * 10 = 15),
        call    #divNumbers             ; and then we divide by 10
        pop.w   R15                     ; Recover value of R15 from stack
        ret

// Objetivo: Calcula el BPM despues que transcurrieron 30 segundos
// Precondiciones: La cantidad de heart beats se encuentra almacenada en R14
// Postcondiciones: El valor de BPM se encuentra almacenado en R14
// Autor: Abdiel Cortés Cortés
// Fecha: 24/abril/2021
calcBPM30:
        push.w  R15                     ; Save value of R15 in stack
        mov     #2, R15                 ; 30 seconds is 1/2 of a second
        call    #mulNumbers             ; Multiply heart beats by 2 to calculate BPM
        mov     R14, result             ; Save the final result on RAM
        pop.w   R15                     ; Recover value of R15 from stack
        ret   


// Objetivo: Multiplicar los números en R14 y R15, para entonces guardarlos en R14.
// R14 = R14 * R15
// Precondiciones: R14 y R15 contienen los números a ser multiplicados 
// Postcondiciones: R14 contiene el producto de la multiplicacion
// Autor: Joshua Cruz Cintrón, Abdiel Cortés Cortés
// Fecha: 24/abril/2021
mulNumbers:                             ; Operation for multiplying 2 numbers
        push.w  R6                      ; Push R6 and R7 to stack so that we can 
        push.w  R7                      ; later recover their original values
        cmp     #0,R15                  ; Check if the R15 = 0
        jeq     multZero                ; If R15 = 0 then result = 0 
        cmp     #0,R14                  ; Check if the R14 = 0
        jeq     multZero                ; If R14 = 0 then result = 0 
    multSetup:                          ; Setup numbers in the proper order
                                        ; for multiplication
        cmp     R14, R15                ; Compare which number is bigger
        jl      multAlgorithm           ; If R14>R15 then multiply both numbers
        call    #multSwitchNumbers      ; If R15>R14 then reverse both numbers
    multAlgorithm:                      ; Algorithm for multiplying 2 numbers
        mov     R14, R6                 ; Re-aranging data for multiplication
        mov     R15, R7                 ; Re-aranging data for multiplication
    multLoop:                           ; Lable used for looping
        dec     R7                      ; Decrement by 1
        jz      multDone                ; Multiplication is finished
        add     R6, R14                 ; Remember that multiplication is
                                        ; just a series of additions
        jmp     multLoop                ; Multiplication not done
    multDone:                           ; Multiplication finished
        pop.w   R7                      ; Pop from stack to recover original 
        pop.w   R6                      ; values of R6 and R7
        ret
    multZero:                           ; Multiplication result is 0
        mov     #0, R14                 ; Save a 0 in R14
        jmp     multDone

// Objetivo: Intercambiar los números de los registros R14 y R15
// Precondiciones: R14 contiene el número menor
// Postcondiciones: R14 contiene el número mayor
// Autor: Joshua Cruz Cintrón
// Fecha: 24/abril/2021
multSwitchNumbers:                      ; Invert the data on both R14 and R15
        push.w   R15                    ; Pushed to the stack so we dont 
                                        ; override the data
        mov      R14, R15               ; Swap R14 to R15
        pop.w    R14                    ; Retrieve the data from the stack
        ret                             ; Swapping done


// Objetivo: Tomar el valor almacenado en R14 y dividirlo con el valor almacenado 
// en R15; el resultado se guarda en R14 (R14 = R14 / R15).
// Precondiciones: En R14 esta almacenado el primer numero en binario y en R15 
// esta almacenado el segundo numero en binario.
// Postcondiciones: El resultado de la division estara almacenado en R14 y en R5;
// R15 siempre sera 0.
// Autor: Abdiel Cortés Cortés
// Fecha: 24/abril/2021
divNumbers:                             ; Operation for dividing 2 numbers
        push.w  R5                      ; Use stack to save original value of R5
        cmp     #0,R15                  ; Check if the denominator is 0
        jeq     divZero                 ; Cant divide by 0
        cmp     #0,R14                  ; Check if the numerator is 0
        jeq     divZero                 ; If 0 then result = 0
        mov     #0, R5                  ; R5 = quotient = 0   
    divLoop:                            ; Label used for looping
        sub     R15, R14                ; R14 = R14 - R15
        cmp     #0, R14                 ; Compare to see if we can keep subtracting
        jl      divEnd                  ; R14 < 0, its negative so we subtracted
                                        ; too much
        inc     R5                      ; Quotient += 1
        jmp     divLoop                 ; Keep dividing    
    divEnd:                             ; Division finished
        mov     R5, R14                 ; Save result in R14
        pop.w   R5                      ; Use stack to recover R5's value
        ret
    divZero:
        mov     #0, R5                  ; Put 0 in R5, which will later be saved in R14
        jmp     divEnd

// Objetivo: Seperate the result found in R14 into individual digits
// Precondiciones: Value has to be stored in R14, R12 is needed 
// as a counter for digits to seperate, R11 is needed as a counter for how many 
// digits are in the stack, R9 is needed for saving the seperated digit from 
// result, R4 is needed for subtracting the result by the specified tens
// Postcondiciones: R9, R10, R11 will house a seperate digit from least to most
// significant digits. R4, R12, R14, will not lose the previous values they had 
// before calling this subroutine. 
// Autor: Daniel A. Crespo 
// Fecha: 24/04/2021
seperateDigits:                         ; Subroutine used for seperating the 
        push.w  R4                      ; results found in R14 and R15 (if any) 
        push.w  R12
        push.w  R14
        mov     #4,R12                  ; R12 serves as a counter for seperating
                                        ; each digit. At first it removes whats 
                                        ; inside R15
        mov     #0,R11                  ; R11 serves as a counter for seperating
                                        ; 6 digits
    loop:                               ; Lable used for looping
        dec     R12                     ; Decrements by 1 meaning seperate to 
                                        ; the next lower tenses 
        mov     #0, R9                  ; R9 = quotient = 0
        cmp     #1,R12                  ; R12=1 means seperate by ones
        jeq     ones                    ; Seperate ones
        cmp     #2,R12                  ; R12=2 means seperate by tens
        jeq     tens                    ; Seperate tens
        cmp     #3,R12                  ; R12=3 means seperate by hundreds
        jeq     hundreds                ; Seperate hundreds
        jmp     finished                ; Switch whats inside register R14 to R15
                                        ; or it means that seperation is finished
    
    ones:                               ; If we are seperating the ones then
        mov     R14,R9                  ; move R15 to R9 because its already in 
                                        ; the tense form
        mov     #0,R14                  ; Clear R15 for later use
        jmp     pushDigit               ; Push the digit on the stack

    tens:                               ; If we are seperating the tens then
        mov     #10,R4                  ; set R4 to 10 so we can subtract by tens
        jmp     subWithTenses           ; Sub R15 at the specified tens   

    hundreds:                           ; If we are seperating the hundreds then
        mov     #100,R4                 ; set R4 to 100 so we can subtract by hundreds
        jmp     subWithTenses           ; Sub R15 at the specified tens
        
    subWithTenses:                      ; General subroutine to seperate digits
                                        ; by the specified tens
        cmp     R4,R14                  ; R4<R5 means that the number is a lower tens
        jl      pushDigit               ; Push the digit to the stack
        sub     R4,R14                  ; Sub R4-R15 by the specified tens
        inc     R9                      ; Increment R9 by 1 meaning its the quotient
        jmp     subWithTenses           ; Keep subtracting by the specified tens
    
    pushDigit:                          ; Push digit on the stack for later use
        push.w  R9                      ; Push R9 = quotient = seperated digit
        inc     R11                     ; Increment R11 by 1 meaning we have 1 more saved digit
        jmp     loop                    ; Restart the loop again

    finished:                           ; Seperation of digits is completed
       ;Least Significant
        pop.w   R9
        pop.w   R10
        pop.w   R11
       ;Most Significant
        pop.w   R14
        pop.w   R12
        pop.w   R4
       ;Revert changes from these registers
        ret

// Objetivo: Print out the result of the readings
// Precondiciones: R9, R10, R11 represents the digits to print out
// Postcondiciones: Display will show the results on the first 3 segments then 
// the word BPM on the last 3 segments. Left ceros will not be displayed.
// Autor: Daniel A. Crespo
// Fecha: 24/04/2021
displayResults:
        call    #seperateDigits
        call    #clearPrevResult
        push.w  R9
        push.w  R10
        push.w  R11
        mov     #4,R10                  ; R10 represents the 3 digits we are going to display
        mov     #0,R11                  ; R11 is used as a flag for if digit has 
                                        ; 0 on the left side of the result, but 
                                        ; it also serves as an indicator as to 
                                        ; were to display the number
    displayNextDigit:                   ; Lable used for looping the next digit to display
        dec     R10                     ; Decrement R10 by 1 meaning a digit is
                                        ; being displayed
        cmp     #0,R10                  ; R10=0 it means that all digits have been displayed
        jeq     resultsDone             ; Result has finally finished printing
        pop     R9                      ; Pop the digit from the stack
        cmp     #1,R11                  ; If R11 >= 1 then that means that their are
        jge     noMoreLeftZeros         ; no mores zeros to the left of the number
        cmp     #0,R9                   ; If R9=0 that means that a zero was
        jeq     displayNextDigit        ; found on the left of the digit so skip
    noMoreLeftZeros:                    ; No more zeros found on the left side
        inc     R11                     ; Increment R11 by 1 to display the next
                                        ; digit on the next display segment
        cmp     #1,R11                  ; R11=1 means that the first display
                                        ; segment can be used for displaying the digit
        jeq     displayFirstDigit       ; Display digit on the first segment
        cmp     #2,R11                  ; R11=2 means that the second display
                                        ; segment can be used for displaying the digit
        jeq     displaySecondDigit      ; Display digit on the second segment
        cmp     #3,R11                  ; R11=3 means that the third display
                                        ; segment can be used for displaying the digit
        jeq     displayThirdDigit       ; Display digit on the third segment
        
    displayFirstDigit:                  ; Display digit on the first segment
        call    #displayFirstSegment    ; Call subroutine for displaying digit 
                                        ; on the first segment display
        jmp     displayNextDigit        ; Go to the next digit for displaying
        
    displaySecondDigit:                 ; Display digit on the second segment
        call    #displaySecondSegment   ; Call subroutine for displaying digit 
                                        ; on the second segment display
        jmp     displayNextDigit        ; Go to the next digit for displaying
        
    displayThirdDigit:                  ; Display digit on the Third segment
        call    #displayThirdSegment    ; Call subroutine for displaying digit 
                                        ; on the Third segment display
        jmp     displayNextDigit        ; Go to the next digit for displaying
        
    resultsDone:                        ; Result has finally finished printing
        call    #displayBPM
        ret

// Objetivo: Delet the previous result from the LCD
// Precondiciones: Must be called when displaying results
// Postcondiciones: The first 3 segments will not display anything
// Autor: Daniel A. Crespo
// Fecha: 25/04/2021
clearPrevResult:
        bic.b   #11111111B, &0x0A29      
        bic.b   #11111111B, &0x0A29+1
        bic.b   #11111111B, &0x0A25      
        bic.b   #11111111B, &0x0A25+1
        bic.b   #11111111B, &0x0A23      
        bic.b   #11111111B, &0x0A23+1
        ret

// Objetivo: Display a number on the first segment of the LCD Display
// Precondiciones: R9 contains the position of the number that should be displayed
// Postcondiciones: LCD will display a number at the first segment
// Autor: Rey J. Cotto
// Fecha: 24/04/2021
displayFirstSegment:                    
        mov.b   digitH(R9), &0x0A29      
        mov.b   digitL(R9), &0x0A29+1
        ret

// Objetivo: Display a number on the second segment of the LCD Display
// Precondiciones: R9 contains the position of the number that should be displayed
// Postcondiciones: LCD will display a number at the second segment
// Autor: Rey J. Cotto
// Fecha: 24/04/2021
displaySecondSegment:                   
        mov.b   digitH(R9), &0x0A25      
        mov.b   digitL(R9), &0x0A25+1
        ret

// Objetivo: Display a number on the third segment of the LCD Display
// Precondiciones: R9 contains the position of the number that should be displayed
// Postcondiciones: LCD will display a number at the third segment
// Autor: Rey J. Cotto
// Fecha: 24/04/2021
displayThirdSegment:                    
        mov.b   digitH(R9), &0x0A23      
        mov.b   digitL(R9), &0x0A23+1
        ret

// Objetivo: Display the word "OPTION" on the LCD Display
// Precondiciones: Program must be in stage 0
// Postcondiciones: LCD will display "OPTION" on the LCD Display
// Autor: Rey J. Cotto
// Fecha: 24/04/2021
displayOption:
        mov.w   #2, &LCDCMEMCTL         ; Clear LCD memory
        mov.b   #0xFC, &0X0a29  ;O-H
        mov.b   #0x00, &0X0a2a  ;O-L
        mov.b   #0xCF, &0X0a25  ;P-H
        mov.b   #0x00, &0X0a26  ;P-L
        mov.b   #0x80, &0X0a23  ;T-H
        mov.b   #0x50, &0X0a24  ;T-L
        mov.b   #0x90, &0X0a32  ;I-H
        mov.b   #0x50, &0X0a33  ;I-L
        mov.b   #0xFC, &0X0a2e  ;O-H
        mov.b   #0x00, &0X0a2f  ;O-L
        mov.b   #0x6C, &0X0a27  ;N-H
        mov.b   #0x82, &0X0a28  ;N-L
        ret

// Objetivo: Display the word "READ" on the LCD Display
// Precondiciones: Program must be in stage 1
// Postcondiciones: LCD will display "READ" on the LCD Display
// Autor: Rey J. Cotto
// Fecha: 24/04/2021
displayRead:
        mov.w   #2, &LCDCMEMCTL         ; Clear LCD memory
        mov.b   #0xCF, &0X0a29  ;R-H
        mov.b   #0x02, &0X0a2a  ;R-L
        mov.b   #0x9E, &0X0a25  ;E-H
        mov.b   #0x00, &0X0a26  ;E-L
        mov.b   #0xEF, &0X0a23  ;A-H
        mov.b   #0x00, &0X0a24  ;A-L
        mov.b   #0xF0, &0X0a32  ;D-H
        mov.b   #0x50, &0X0a33  ;D-L
        ret

// Objetivo: Display the word "LOG" on the LCD Display
// Precondiciones: Program must be in stage 3
// Postcondiciones: LCD will display "LOG" on the LCD Display
// Autor: Rey J. Cotto
// Fecha: 24/04/2021
displayLog:
        mov.w   #2, &LCDCMEMCTL         ; Clear LCD memory
        mov.b   #0x1C, &0X0a29  ;L-H
        mov.b   #0x00, &0X0a2a  ;L-L
        mov.b   #0xFC, &0X0a25  ;O-H
        mov.b   #0x00, &0X0a26  ;O-L
        mov.b   #0xBD, &0X0a23  ;G-H
        mov.b   #0x00, &0X0a24  ;G-L
        ret

// Objetivo: Display the word "BPM" on the LCD Display
// Precondiciones: Must be called when displaying a result
// Postcondiciones: LCD will display "BPM" on the LCD Display
// Autor: Rey J. Cotto
// Fecha: 24/04/2021
displayBPM:
        mov.b   #0xF1, &0X0a32 ;B-H
        mov.b   #0x50, &0X0a33 ;B-L
        mov.b   #0xCF, &0X0a2e ;P-H
        mov.b   #0x00, &0X0a2f ;P-L
        mov.b   #0x6C, &0X0a27 ;M-H
        mov.b   #0xA0, &0X0a28 ;M-L
        ret

// Objetivo: Display the word "SAVE" on the LCD Display
// Precondiciones: Program must be in stage 8
// Postcondiciones: LCD will display "SAVE" on the LCD Display
// Autor: Rey J. Cotto
// Fecha: 24/04/2021
displaySave:
        mov.w   #2, &LCDCMEMCTL         ; Clear LCD memory
        mov.b   #0xB7, &0X0a29  ;S-H
        mov.b   #0x00, &0X0a2a  ;S-L
        mov.b   #0xEF, &0X0a25  ;A-H
        mov.b   #0x00, &0X0a26  ;A-L
        mov.b   #0x0C, &0X0a23  ;V-H
        mov.b   #0x28, &0X0a24  ;V-L
        mov.b   #0x9E, &0X0a32  ;E-H
        mov.b   #0x00, &0X0a33  ;E-L
        ret

// Objetivo: Clears the battery cells from the display
// Precondiciones: Must be called when battery reaches full
// Postcondiciones: LCD will not display any battery cells
// Autor: Daniel A. Crespo
// Fecha: 25/04/2021
clearBatteryCells:
        bic.b   #00100000B,&0x0A31      ; cell 1
        bic.b   #00100000B,&0x0A2D      ; cell 2
        bic.b   #01000000B,&0x0A31      ; cell 3
        bic.b   #01000000B,&0x0A2D      ; cell 4
        bic.b   #10000000B,&0x0A31      ; cell 5
        bic.b   #10000000B,&0x0A2D      ; cell 6
        ret
        
// Objetivo: Displays the edges of the battery
// Precondiciones: Program must be in stage 6
// Postcondiciones: LCD will display the edges of the battery
// Autor: Daniel A. Crespo
// Fecha: 25/04/2021
edgeOfBattery:
        mov.b   #00010000B, &0x0A31     ; Turn on edge of batery
        ret
        
        END
